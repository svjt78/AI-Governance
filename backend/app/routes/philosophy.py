"""Governance philosophy API routes"""
import os
from typing import List, Optional
from fastapi import APIRouter, Query, HTTPException
from fastapi.responses import FileResponse
from datetime import datetime

from app.models.philosophy import GovernancePhilosophy, PhilosophyScope
from app.storage.ndjson_storage import NDJSONStorage
from app.services.philosophy_llm import PhilosophyLLMService
from app.services.audit_logger import AuditLogger
from app.config import settings

router = APIRouter()

PHILOSOPHY_FILE = os.path.join(settings.data_dir, "governance_philosophy.ndjson")


@router.post("/governance/philosophy", response_model=GovernancePhilosophy)
async def create_or_update_philosophy(
    philosophy: GovernancePhilosophy,
    use_llm_to_fill_gaps: bool = Query(False)
):
    """Create or update governance philosophy"""
    # Use LLM to fill gaps if requested
    if use_llm_to_fill_gaps:
        philosophy = PhilosophyLLMService.fill_philosophy_gaps(philosophy)

    # Append to philosophy log
    NDJSONStorage.append(PHILOSOPHY_FILE, philosophy.model_dump(mode='json'))

    # Log audit event
    AuditLogger.log(
        action_type="create_philosophy",
        entity_type="philosophy",
        entity_id=f"{philosophy.scope}_{philosophy.scope_ref}",
        new_value=philosophy.model_dump(mode='json')
    )

    return philosophy


@router.get("/governance/philosophy", response_model=List[GovernancePhilosophy])
async def get_philosophy(
    scope: Optional[PhilosophyScope] = Query(None),
    scope_ref: Optional[str] = Query(None)
):
    """Get governance philosophy entries"""
    all_philosophies = NDJSONStorage.read_all(PHILOSOPHY_FILE)

    # Apply filters
    if scope:
        all_philosophies = [p for p in all_philosophies if p.get('scope') == scope.value]

    if scope_ref:
        all_philosophies = [p for p in all_philosophies if p.get('scope_ref') == scope_ref]

    # Sort by updated_at descending
    all_philosophies.sort(key=lambda x: x.get('updated_at', ''), reverse=True)

    return [GovernancePhilosophy(**p) for p in all_philosophies]


@router.delete("/governance/philosophy")
async def delete_philosophy(
    scope: PhilosophyScope = Query(...),
    scope_ref: str = Query(...)
):
    """Delete a governance philosophy entry"""
    # Delete the philosophy
    deleted_count = NDJSONStorage.delete_record(
        PHILOSOPHY_FILE,
        scope=scope.value,
        scope_ref=scope_ref
    )

    if deleted_count == 0:
        raise HTTPException(
            status_code=404,
            detail=f"Philosophy not found for scope={scope.value}, scope_ref={scope_ref}"
        )

    # Log audit event
    AuditLogger.log(
        action_type="delete_philosophy",
        entity_type="philosophy",
        entity_id=f"{scope.value}_{scope_ref}",
        old_value={"scope": scope.value, "scope_ref": scope_ref}
    )

    return {
        "status": "success",
        "message": f"Philosophy deleted: {scope.value} - {scope_ref}",
        "deleted_count": deleted_count
    }


@router.get("/governance/philosophy/download")
async def download_philosophy(
    scope: PhilosophyScope = Query(...),
    scope_ref: str = Query(...)
):
    """Download a governance philosophy as a markdown file"""
    # Find the philosophy
    all_philosophies = NDJSONStorage.read_all(PHILOSOPHY_FILE)
    matching_phil = None

    for p in all_philosophies:
        if p.get('scope') == scope.value and p.get('scope_ref') == scope_ref:
            matching_phil = p
            break

    if not matching_phil:
        raise HTTPException(
            status_code=404,
            detail=f"Philosophy not found for scope={scope.value}, scope_ref={scope_ref}"
        )

    # Parse as GovernancePhilosophy model
    philosophy = GovernancePhilosophy(**matching_phil)

    # Generate markdown content
    md_content = f"""# Governance Philosophy: {philosophy.scope_ref}

**Scope:** {philosophy.scope}
**Scope Reference:** {philosophy.scope_ref}
**Created:** {datetime.fromisoformat(philosophy.created_at.isoformat()).strftime('%B %d, %Y at %I:%M %p UTC')}
**Last Updated:** {datetime.fromisoformat(philosophy.updated_at.isoformat()).strftime('%B %d, %Y at %I:%M %p UTC')}
**Generated by LLM:** {'Yes' if philosophy.generated_by_llm else 'No'}

---

## Risk Appetite

{philosophy.risk_appetite if philosophy.risk_appetite else '_Not specified_'}

## Fairness & Unfair Discrimination Principles

{philosophy.fairness_and_unfair_discrimination_principles if philosophy.fairness_and_unfair_discrimination_principles else '_Not specified_'}

## External Data & Vendor Controls

{philosophy.external_data_and_vendor_controls if philosophy.external_data_and_vendor_controls else '_Not specified_'}

## Regulatory Alignment Principles

{philosophy.regulatory_alignment_principles if philosophy.regulatory_alignment_principles else '_Not specified_'}

## Safety & Customer Protection Principles

{philosophy.safety_and_customer_protection_principles if philosophy.safety_and_customer_protection_principles else '_Not specified_'}

## Explainability & Customer Communication

{philosophy.explainability_and_customer_communication if philosophy.explainability_and_customer_communication else '_Not specified_'}

## Auditability & DOI Exam Readiness

{philosophy.auditability_and_DOI_exam_readiness if philosophy.auditability_and_DOI_exam_readiness else '_Not specified_'}

## Lifecycle Governance

{philosophy.lifecycle_governance if philosophy.lifecycle_governance else '_Not specified_'}

---

_This governance philosophy document was exported from InsureGov AI Governance Platform._
"""

    # Save to temp file
    timestamp = datetime.utcnow().strftime('%Y-%m-%d')
    safe_scope_ref = scope_ref.replace(' ', '_').replace('/', '_').replace('&', 'and')
    filename = f"philosophy_{safe_scope_ref}_{timestamp}.md"
    temp_file_path = os.path.join(settings.data_dir, "temp", filename)

    # Ensure temp directory exists
    os.makedirs(os.path.dirname(temp_file_path), exist_ok=True)

    # Write markdown content
    with open(temp_file_path, 'w', encoding='utf-8') as f:
        f.write(md_content)

    # Return as downloadable file
    return FileResponse(
        path=temp_file_path,
        media_type='text/markdown',
        filename=filename,
        headers={
            'Content-Disposition': f'attachment; filename="{filename}"'
        }
    )
